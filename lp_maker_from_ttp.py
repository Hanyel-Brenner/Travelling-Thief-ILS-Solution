# -*- coding: utf-8 -*-
"""LP_maker_from_ttp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dvBdQciDo6e9TBs1d2nug-vFqDjVWIbZ

## Leitor de instâncias TTP
* Richard Rangel do N. Junior         156575
* Hanyel Brenner Camargos de Paula 156503
* Guilherme Vieira Justino 150007
"""
import gurobipy as grb
import numpy as np
import random
import math
import os
import time
import csv

class TravelingThiefProblem:
    def __init__(self):
        self.problem_name = ""
        self.knapsack_capacity = 0
        self.num_items = 0
        self.min_speed = 0
        self.max_speed = 0
        self.renting_ratio = 0
        self.edge_weight_type = ""
        self.nodes = []
        self.items = []

    def read_from_file(self, filename):
        with open(filename, 'r') as file:
            lines = file.readlines()

        # Process the problem name and general parameters
        for line in lines:
            if line.startswith('PROBLEM NAME'):
                self.problem_name = line.split(':')[1].strip()
            elif line.startswith('DIMENSION'):
                self.num_nodes = int(line.split(':')[1].strip())
            elif line.startswith('NUMBER OF ITEMS'):
                self.num_items = int(line.split(':')[1].strip())
            elif line.startswith('CAPACITY OF KNAPSACK'):
                self.knapsack_capacity = int(line.split(':')[1].strip())
            elif line.startswith('MIN SPEED'):
                self.min_speed = float(line.split(':')[1].strip())
            elif line.startswith('MAX SPEED'):
                self.max_speed = float(line.split(':')[1].strip())
            elif line.startswith('RENTING RATIO'):
                self.renting_ratio = float(line.split(':')[1].strip())
            elif line.startswith('EDGE_WEIGHT_TYPE'):
                self.edge_weight_type = line.split(':')[1].strip()

        # Reading node coordinates
        reading_nodes = False
        for line in lines:
            if line.startswith('NODE_COORD_SECTION'):
                reading_nodes = True
            elif reading_nodes:
                if line.startswith('ITEMS SECTION'):
                    break
                node_data = line.split()
                node_index = int(node_data[0])
                x = float(node_data[1])
                y = float(node_data[2])
                self.nodes.append((node_index, x, y))

        # Reading items
        reading_items = False
        for line in lines:
            if line.startswith('ITEMS SECTION'):
                reading_items = True
            elif reading_items:
                item_data = line.split()
                item_index = int(item_data[0])
                profit = int(item_data[1])
                weight = int(item_data[2])
                assigned_node = int(item_data[3])
                self.items.append((item_index, profit, weight, assigned_node))

    def __repr__(self):
        return f"TravelingThiefProblem({self.problem_name}, {self.num_nodes} nodes, {self.num_items} items)"


class tsp_lp_builder:
  def __init__(self, filename, cities):
    self.file = open(filename,'w')
    self.cities = cities
    self.file.close()
    self.x = [[0 for _ in range(len(self.cities))] for _ in range(len(self.cities))]
    self.d = [[0 for _ in range(len(self.cities))] for _ in range(len(self.cities))]

  def setDistanceBetweenCities(self):
    for i in range(len(self.cities)):
      for j in range(len(self.cities)):
        node_index, xi, yi = self.cities[i]
        node_index, xj, yj = self.cities[j]
        if i == j:
          self.d[i][j] = 99999999
        else :
          self.d[i][j] = round(np.sqrt(pow( (xi - xj) ,2) + pow( (yi - yj) , 2)))


  def setObjectiveFunction(self, filename):
      self.file = open(filename, 'a');
      self.file.write('MINIMIZE\n')
      for i in range(0, len(self.cities)):
        for j in range(0, len(self.cities)):
          if j == len(self.cities) - 1 and i != len(self.cities) - 1 : self.file.write(f'{self.d[i][j]} x{i}_{j} +')
          else : self.file.write(f'{self.d[i][j]} x{i}_{j}')
          if j != len(self.cities) - 1 : self.file.write(' + ')
      self.file.write('\n')
      self.file.close()

  def setConstraints(self, filename):
      N = len(self.cities)
      self.file = open(filename, 'a')
      self.file.write('SUBJECT TO\n')

      self.file.write('\nR1:')
      self.file.write('\n')

      for i in range(0, N):
        for j in range(0, N):
          self.file.write(f'x{i}_{j}')
          """if j != (N - 1) and not(i == N - 1 and j == N - 2):
            self.file.write(' + ')"""
          if j != (N - 1):
            self.file.write(' + ')
        self.file.write(' = 1\n')

      self.file.write('\nR2:')
      self.file.write('\n')

      for i in range(0, N):
        for j in range(0, N):
          self.file.write(f'x{j}_{i}')
          """if j != (N - 1) and not( i == N - 1 and j == N - 2) :
            self.file.write(' + ')"""
          if j != (N - 1):
            self.file.write(' + ')
        self.file.write(' = 1\n')

      self.file.write('\nR3:')
      self.file.write('\n')


      for i in range(1, N):
        for j in range(1, N):
          if i != j:
            self.file.write(f'u{i} - u{j} + {N} x{i}_{j} <= {N - 1}\n')
      self.file.write('u1 = 1\n');
      self.file.close()

  def setBounds(self, filename):
    N = len(self.cities)
    self.file = open(filename, 'a')
    self.file.write('BOUNDS\n')
    for i in range(1, N):
      self.file.write(f'u{i} >= 0\n');
    self.file.close();


  def setVariableTypes(self, filename):
    N = len(self.cities)
    self.file = open(filename, 'a')
    self.file.write('\nGENERALS\n')
    for i in range(0, len(self.cities)):
      self.file.write(f'u{i}\n')
    self.file.write('\nBINARIES\n')
    for i in range(0, N):
      for j in range(0, N ):
        self.file.write(f'x{i}_{j}\n')
    self.file.write('END')
    self.file.close()

class kp_lp_builder:
  def __init__(self, filename, items, knapsack_capacity):
    self.file = open(filename,'w')
    self.items = items
    self.knapsack_capacity = knapsack_capacity
    self.file.close()
    self.z = [0]*len(items)

  def setObjectiveFunction(self, filename):
    N = len(self.items)
    self.file = open(filename, 'a');
    self.file.write('MAXIMIZE\n')
    for i in range(0, N):
      item_index, profit, weight, assigned_node = self.items[i]
      if i != N - 1 : self.file.write(f'{profit} z{i} + ')
      else : self.file.write(f'{profit} z{i}')
    self.file.write('\n')
    self.file.close()

  def setConstraints(self, filename):
    N = len(self.items)
    self.file = open(filename, 'a')
    self.file.write('SUBJECT TO\n')
    for i in range(0, N):
      item_index, profit, weight, assigned_node = self.items[i]
      if i != N - 1 : self.file.write(f'{weight} z{i} + ')
      else : self.file.write(f'{weight} z{i} <= {self.knapsack_capacity}')
    self.file.write('\n')
    self.file.close()

  def setBounds(self, filename):
    N = len(self.items)
    self.file = open(filename, 'a')
    self.file.write('BOUNDS\n')
    for i in range(0, N):
      item_index, profit, weight, assigned_node = self.items[i]
      if i != N - 1 : self.file.write(f'{weight} z{i} + ')
      else : self.file.write(f'{weight} z{i}')
    self.file.write('\n')
    self.file.close()

  def setVariableTypes(self, filename):
    N = len(self.items)
    self.file = open(filename, 'a')
    self.file.write('BINARIES\n')
    for i in range(0, N):
      self.file.write(f'z{i}\n')
    self.file.write('END')
    self.file.close()

class result_loader:

  def __init__(self, filename, ttp):
    self.file = open(filename,'r');
    self.lines = self.file.readlines();
    self.ttp = ttp;
    self.file.close();

  def getObjectiveValueIndex(self, problem):
    values = [];
    for line in self.lines:
      if "Objective value" in line:
        values.append(float(line.split('=')[1].strip()));
    if problem == 'kp':
      bestResultIndex = values.index(max(values));
      return bestResultIndex;
    if problem == 'tsp':
      bestResultIndex = values.index(min(values));
      return bestResultIndex;

  def getKpResult(self, bestResultIndex):
    res = [];
    for i in range(bestResultIndex + 1, len(self.lines)):
      if "Objective value" in self.lines[i]:
        break;
      else:
        res.append(float(self.lines[i].split(' ')[1].strip()));
    return res;

  def getTspResult(self, bestResultIndex):
    n = len(self.ttp.nodes);
    x = [[0 for _ in range(0,n)] for _ in range(0,n)];
    u = [0 for _ in range(0,n)];
    nOfLines = len(self.lines);
    for i in range(bestResultIndex + 1, nOfLines):
      if "Objective value" in self.lines[i]:
        break;
      else:
        if "x" in self.lines[i]:
          variable = self.lines[i].split(' ')[0].strip();
          number = float(self.lines[i].split(' ')[1].strip());
          lineIndex = int(variable.split('_')[0].strip()[1:]);
          columnIndex = int(variable.split('_')[1].strip());
          if columnIndex > n - 1 :
            raise Exception()
          x[lineIndex][columnIndex] = number;
        if "u" in self.lines[i]:
          variable = self.lines[i].split(' ')[0].strip();
          number = float(self.lines[i].split(' ')[1].strip());
          lineIndex = int(variable[1:])
          u[lineIndex] = number
           
    return x,u

def calculate_ttp_value(ttp, tsp_path, kp_solution):
    """
    Recalcula o valor da função objetivo do TTP levando em conta a variação de peso e velocidade.
    
    :param ttp: Instância do problema (TravelingThiefProblem)
    :param tsp_path: Lista de cidades na ordem da rota
    :param kp_solution: Lista binária indicando quais itens foram selecionados (1 = selecionado, 0 = não)
    :return: Valor da função objetivo
    """
    total_profit = 0
    total_weight = 0
    total_time = 0

    # Verifica se a cidade de origem está no final do caminho
    if tsp_path[-1] != tsp_path[0]:
        tsp_path.append(tsp_path[0])  # Garante que o ciclo é fechado

    # Cria um dicionário para mapear quais itens estão em cada cidade
    items_in_city = {city: [] for city in range(1, ttp.num_nodes + 1)}
    for i, selected in enumerate(kp_solution):
        if selected:
            item_index, profit, weight, assigned_node = ttp.items[i]
            items_in_city[assigned_node].append((profit, weight))
            total_profit += profit  # Soma o lucro dos itens selecionados

    # Percorre a rota do TSP e calcula o tempo total de viagem
    for i in range(len(tsp_path) - 1):
        city1 = tsp_path[i]
        city2 = tsp_path[i + 1]

        x1, y1 = ttp.nodes[city1 - 1][1], ttp.nodes[city1 - 1][2]
        x2, y2 = ttp.nodes[city2 - 1][1], ttp.nodes[city2 - 1][2]

        distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

        # Antes de viajar para a próxima cidade, verificar se pegamos itens nesta cidade
        if city1 in items_in_city:
            for profit, weight in items_in_city[city1]:
                total_weight += weight  # Atualiza o peso carregado

        # Calcula a velocidade dinâmica antes de percorrer a distância
        current_speed = ttp.max_speed - ((total_weight / ttp.knapsack_capacity) * (ttp.max_speed - ttp.min_speed))
        travel_time = distance / current_speed
        total_time += travel_time  # Acumula o tempo de viagem

    # Calcula a função objetivo final
    ttp_value = total_profit - (ttp.renting_ratio * total_time)
    return ttp_value



class iterated_local_search:
  def __init__(self, ttp, kp_sol, tsp_sol, n, m):
    self.ttp = ttp;
    self.kp_sol = kp_sol[:];
    self.tsp_sol = tsp_sol[:];
    self.kp_size = n;
    self.tsp_size = m;
    self.profit = 0;

  #tem uma margem de minimo e maximo
  def iterate(self, numIter, perturbationFactorMin , perturbationFactorMax):
    baseResult = calculate_ttp_value(self.ttp, self.tsp_sol ,self.kp_sol)
    exactSol = baseResult
    kp_sol = self.kp_sol[:];
    tsp_sol = self.tsp_sol[:];
    kp_sol_perturbed = self.kp_sol[:];
    tsp_sol_perturbed = self.tsp_sol[:];

    for counter in range(numIter):
      #Escolhe o ttp ou o kp aleatoriamente para pertubar
      switch = random.randint(0,1);
      if(switch == 0):
        temp_sol = self.perturbation(kp_sol, perturbationFactorMin, perturbationFactorMax, counter,'kp');
        #verifica se a capacidade máxima da mochila não foi violada
        totalWeight = 0
        for item_index, profit, weight, assigned_node in self.ttp.items:
  
          if temp_sol[item_index - 1] == 1: 
            totalWeight += weight 

        if totalWeight > self.ttp.knapsack_capacity:
          kp_sol_perturbed = kp_sol[:]
        else:
          kp_sol_perturbed = temp_sol[:]
      else:
        tsp_sol_perturbed = self.perturbation(tsp_sol, perturbationFactorMin, perturbationFactorMax, counter,'tsp');
      
      #calcula novo resultado baseado na perturbação
      newResult = calculate_ttp_value(self.ttp, tsp_sol_perturbed, kp_sol_perturbed)
      
      #se o novo lucro encontrado for maior que o ultimo lucro aceito, subtitua a solução e o valor para ser usado na proxima iteração
      if newResult > baseResult:
        baseResult = newResult
        kp_sol = kp_sol_perturbed[:]
        tsp_sol = tsp_sol_perturbed[:]

    self.profit = baseResult    
    return exactSol, kp_sol, tsp_sol

  def perturbation(self, sol, perturbationFactormin, perturbationFactormax, iterNumber ,problemType):
    perturbationFactor = random.uniform(perturbationFactormin, perturbationFactormax);
    temp_sol = sol[:]
    if(problemType == 'kp'):
      i = random.randint(0, self.kp_size-1);
      min_j = max(0, i - int(perturbationFactor * self.kp_size))
      max_j = min(self.kp_size - 1, i + int(perturbationFactor * self.kp_size))
      j = random.randint(min_j, max_j);
      temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i];
      return temp_sol[:];

    if(problemType == 'tsp'):
      i, j = random.sample(range(self.tsp_size), 2)  # Escolhe dois índices distintos
      temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]  # Realiza a troca
      return temp_sol[:];
  
  def getFinalResult(self):
    return self.profit
  

#Travelling thief problem is read
def generate_kp_LPs(ttpDirectoryPath, lpOutDir):
  os.makedirs(lpOutDir)
  for element in os.listdir(ttpDirectoryPath):
    print(element)
    temp = element.split('.')[0]
    kp_lp_path = os.path.join(lpOutDir, temp + '-kp.lp')

    ttp = TravelingThiefProblem()
    ttp.read_from_file(os.path.join(ttpDirectoryPath,element))

    kp = kp_lp_builder(kp_lp_path, ttp.items, ttp.knapsack_capacity)
    kp.setObjectiveFunction(kp_lp_path)
    kp.setConstraints(kp_lp_path)  
    kp.setVariableTypes(kp_lp_path)

def generate_tsp_LPs(ttpDirectoryPath, lpOutDir):
   os.makedirs(lpOutDir)
   for element in os.listdir(ttpDirectoryPath):
    print(element)
    temp = element.split('.')[0]
    tsp_lp_path = os.path.join(lpOutDir, temp + '-tsp.lp')

    ttp = TravelingThiefProblem()
    ttp.read_from_file(os.path.join(ttpDirectoryPath,element))

    tsp = tsp_lp_builder(tsp_lp_path,ttp.nodes)
    tsp.setDistanceBetweenCities()
    tsp.setObjectiveFunction(tsp_lp_path)
    tsp.setConstraints( tsp_lp_path)
    tsp.setBounds(tsp_lp_path)
    tsp.setVariableTypes(tsp_lp_path)

def solve_LPs(lpFilesDir, solOutDir):
   os.makedirs(solOutDir)
   for element in os.listdir(lpFilesDir):
    temp = element.split('.')[0]
    outDirPath = os.path.join(solOutDir, temp + '.sol')
    model = grb.read(os.path.join(lpFilesDir, element))
    model.optimize()
    model.write(outDirPath)

def applyHeuristic(ttpInstanceDir, kpSolDir, HeuristicSolDir, numIter, perturbationFactorMin, perturbationFactorMax):
   tsp_result_eil51 = [1, 22, 2, 16, 50, 34, 21, 29, 20, 35, 36, 3, 28, 31, 8, 26, 7, 43, 24, 23, 48, 6, 27, 46, 12, 47, 4, 18, 14, 25, 13, 41, 19, 40, 42, 44, 17, 37, 15, 45, 33, 39, 10, 30, 9, 49, 5, 38, 11, 32, 1]
   tsp_result_pr152 = [1, 35, 36, 34, 47, 51, 73, 75, 48, 49, 50, 76, 74, 77, 93, 94, 95, 92, 78, 91, 96, 115, 116, 124, 125, 126, 152, 150, 151, 127, 128, 123, 122, 129, 130, 149, 148, 147, 131, 132, 121, 120, 133, 134, 146, 145, 144, 135, 136, 119, 118, 137, 138, 143, 142, 141, 139, 140, 117, 110, 109, 108, 85, 84, 86, 107, 106, 105, 83, 87, 104, 111, 112, 82, 88, 103, 102, 101, 81, 89, 100, 113, 114, 80, 90, 99, 98, 97, 79, 71, 72, 53, 52, 46, 70, 69, 54, 45, 44, 55, 56, 68, 67, 66, 65, 57, 43, 42, 58, 59, 64, 63, 62, 61, 60, 41, 40, 18, 17, 9, 8, 10, 19, 21, 20, 7, 11, 22, 23, 39, 6, 12, 24, 25, 26, 5, 13, 27, 28, 38, 4, 14, 29, 30, 31, 3, 15, 32, 33, 37, 2, 16,1] 
   tsp_result_a280 = [1, 2, 242, 243, 244, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 246, 245, 247,250, 251, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214,213, 212, 211, 210, 207, 206, 205, 204, 203, 202, 201, 198, 197, 196, 195, 194, 193, 192, 191,190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 176, 180, 179, 150, 178, 177, 151, 152, 156,153, 155, 154, 129, 130, 131, 20, 21, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 157,158, 159, 160, 175, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 172, 171, 173, 174, 107,106, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 109, 108, 110,111, 112, 88, 87, 113, 114, 115, 117, 116, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74,73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45,44, 59, 63, 62, 118, 61, 60, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28,27, 26, 22, 25, 23, 24, 14, 15, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 277, 276, 275, 274, 273, 272,271, 16, 17, 18, 19, 132, 133, 134, 270, 269, 135, 136, 268, 267, 137, 138, 139, 149, 148, 147,146, 145, 199, 200, 144, 143, 142, 141, 140, 266, 265, 264, 263, 262, 261, 260, 259, 258, 257,254, 253, 208, 209, 252, 255, 256, 249, 248, 278, 279, 3, 280,1]
   if(not(os.path.exists(HeuristicSolDir))):
    os.makedirs(HeuristicSolDir)

   file = open(os.path.join(HeuristicSolDir, f'solution_{perturbationFactorMax*10}.txt'), 'w')
   file.write('Solutions\n',)
   file.close()

   data = []

   for element in os.listdir(ttpInstanceDir):
    temp = element.split('.')[0]
    solFilePath = os.path.join( kpSolDir, temp + '-kp.sol')

    ttp = TravelingThiefProblem()
    ttp.read_from_file(os.path.join(ttpInstanceDir , element))

    resLoader = result_loader( solFilePath, ttp)
    kp_result = resLoader.getKpResult(resLoader.getObjectiveValueIndex('kp'))

    tempo_inicial = time.time()
    if 'eil51' in element:
      ils_instance = iterated_local_search(ttp, kp_result, tsp_result_eil51, len(kp_result), len(tsp_result_eil51))
      exactSol,sol1, sol2 = ils_instance.iterate(numIter, perturbationFactorMin, perturbationFactorMax)
      finalResult = ils_instance.getFinalResult()

    if 'pr152' in element:
      ils_instance = iterated_local_search(ttp, kp_result, tsp_result_pr152, len(kp_result), len(tsp_result_pr152))
      exactSol, sol1, sol2 = ils_instance.iterate(numIter, perturbationFactorMin, perturbationFactorMax)
      finalResult = ils_instance.getFinalResult()

    if 'a280' in element:
      ils_instance = iterated_local_search(ttp, kp_result, tsp_result_a280, len(kp_result), len(tsp_result_a280))
      exactSol,sol1, sol2 = ils_instance.iterate(numIter, perturbationFactorMin, perturbationFactorMax)
      finalResult = ils_instance.getFinalResult()
    
    tempo_final = time.time()
    tempo_gasto = tempo_final - tempo_inicial

    file = open(os.path.join(HeuristicSolDir, f'solution_{perturbationFactorMax*10}.txt'), 'a')
    file.write(f'{element}\t{exactSol}\t{finalResult}\t{tempo_gasto}s\t{finalResult - exactSol}\n')
    file.close()
    data.append([element , float(exactSol), float(finalResult), tempo_gasto, perturbationFactorMax])
   return data
   
generate_kp_LPs('ttp-instances', 'kp_lp_files')
generate_tsp_LPs('ttp-instances', 'tsp_lp_files')
solve_LPs('kp_lp_files', 'kp_sol_files')
#solve_LPs('tsp_lp_files', 'tsp_sol_files')

#for i in range(0, 10):
data = applyHeuristic('ttp-instances', 'kp_sol_files' , 'Solution2', 10000, 0.1, 0.9 )
with open('RECORDS.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)
"""
data = applyHeuristic('ttp-instances', 'kp_sol_files' , 'Solution2', 0, 10000, 0.2 )
with open('RECORDS.csv', 'a', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)

data = applyHeuristic('ttp-instances', 'kp_sol_files' , 'Solution2', 0, 10000, 0.3 )
with open('RECORDS.csv', 'a', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)

data = applyHeuristic('ttp-instances', 'kp_sol_files' , 'Solution2', 0, 10000, 0.4 )
with open('RECORDS.csv', 'a', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)

data = applyHeuristic('ttp-instances', 'kp_sol_files' , 'Solution2', 0, 10000, 0.5 )
with open('RECORDS.csv', 'a', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)

data = applyHeuristic('ttp-instances', 'kp_sol_files' , 'Solution2', 0, 10000, 0.6 )
with open('RECORDS.csv', 'a', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)

data = applyHeuristic('ttp-instances', 'kp_sol_files' , 'Solution2', 0, 10000, 0.7 )
with open('RECORDS.csv', 'a', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)

data = applyHeuristic('ttp-instances', 'kp_sol_files' , 'Solution2', 0, 10000, 0.8 )
with open('RECORDS.csv', 'a', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)

data = applyHeuristic('ttp-instances', 'kp_sol_files' , 'Solution2', 0, 10000, 0.9 )
with open('RECORDS.csv', 'a', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)

data = applyHeuristic('ttp-instances', 'kp_sol_files' , 'Solution2', 0, 10000, 0.1 )
with open('RECORDS.csv', 'a', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(data)
"""